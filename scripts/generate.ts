import fs from "fs";
import path from "path";

const SOURCE_PATH = path.resolve(__dirname, "../data/EastAsianWidth.txt");
const TARGET_PATH = path.resolve(__dirname, "../src/defs.ts");

const ENCODING = "utf-8";

function readVersion(src: string): string {
  const res = /^# EastAsianWidth-(.+).txt/.exec(src);
  if (!res) {
    throw new Error("failed to get version");
  }
  return res[1];
}

const DEFAULT_PROP_VALUE = "N";
const MIN_CODE_POINT = 0x0000;
const MAX_CODE_POINT = 0x10ffff;

const eastAsianWidths = ["N", "Na", "W", "F", "H", "A"] as const;
type EastAsianWidth = typeof eastAsianWidths[number];

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isEastAsianWidth(prop: any): prop is EastAsianWidth {
  return eastAsianWidths.includes(prop);
}

type EAWDef = Readonly<{
  start: number;
  end: number;
  prop: EastAsianWidth;
}>;

function parseDef(line: string): EAWDef {
  const [range, prop] = line.split(/\s*;\s*/, 2);
  if (!isEastAsianWidth(prop)) {
    throw new Error(`unknown prop: ${prop}`);
  }
  const [startStr, endStr] = range.split(/\s*\.\.\s*/, 2);
  const start = parseInt(startStr, 16);
  const end = parseInt(endStr || startStr, 16);
  if (Number.isNaN(start) || Number.isNaN(end)) {
    throw new Error(`invalid range: ${start}, ${end}`);
  }
  return { start, end, prop };
}

function readDefs(src: string): readonly EAWDef[] {
  const defs = src
    .split(/[\r\n]+/) // split lines
    .map(line => line.replace(/^([^#]*).*$/, "$1").trim()) // strip comments
    .filter(line => line !== "") // remove empty lines
    .map(parseDef); // parse
  // complete and merge definitions
  const completeDefs: EAWDef[] = [];
  let prev: EAWDef | undefined = undefined;
  for (const def of defs) {
    if (!prev) {
      // complete head
      if (def.start !== MIN_CODE_POINT) {
        prev = {
          start: MIN_CODE_POINT,
          end: def.start - 1,
          prop: DEFAULT_PROP_VALUE,
        };
      } else {
        prev = def;
        continue;
      }
    }
    // complete
    if (prev.end + 1 !== def.start) {
      if (prev.prop === DEFAULT_PROP_VALUE) {
        prev = {
          start: prev.start,
          end: def.start - 1,
          prop: DEFAULT_PROP_VALUE,
        };
      } else {
        completeDefs.push(prev);
        prev = {
          start: prev.end + 1,
          end: def.start - 1,
          prop: DEFAULT_PROP_VALUE,
        };
      }
    }
    // merge
    if (prev.prop === def.prop && prev.end + 1 === def.start) {
      prev = {
        start: prev.start,
        end: def.end,
        prop: prev.prop,
      };
    } else {
      completeDefs.push(prev);
      prev = def;
    }
  }
  if (prev) {
    // complete tail
    if (prev.end !== MAX_CODE_POINT) {
      if (prev.prop === DEFAULT_PROP_VALUE) {
        prev = {
          start: prev.start,
          end: MAX_CODE_POINT,
          prop: DEFAULT_PROP_VALUE,
        };
      } else {
        completeDefs.push(prev);
        prev = {
          start: prev.end + 1,
          end: MAX_CODE_POINT,
          prop: DEFAULT_PROP_VALUE,
        };
      }
    }
    // push last def
    completeDefs.push(prev);
  }
  return completeDefs;
}

const HEADER = `/*
 * Generated by script. DO NOT EDIT!
 *
 * The part between BEGIN and END is derived from Unicode Data Files
 * and provided under Unicode, Inc. License Agreement.
 */`;

const IMPORT = `import { EAWDef } from "./types";`;

const BEGIN = `/* BEGIN */`;

const END = "/* END */";

function generateJs(version: string, defs: readonly EAWDef[]): string {
  const elems = defs.map(def => `  [${def.start}, ${def.end}, "${def.prop}"],`).join("\n");
  const js =
    [
      HEADER,
      "",
      IMPORT,
      "",
      BEGIN,
      `export const defs: readonly EAWDef[] = [\n${elems}\n];`,
      END,
      "",
      `export const version: string = ${JSON.stringify(version)};`,
    ].join("\n") + "\n";
  return js;
}

async function main(): Promise<void> {
  const src = await fs.promises.readFile(SOURCE_PATH, { encoding: ENCODING });
  const version = readVersion(src);
  const defs = readDefs(src);
  const js = generateJs(version, defs);
  await fs.promises.writeFile(TARGET_PATH, js, { encoding: ENCODING });
}

main().catch(err => {
  // eslint-disable-next-line no-console
  console.error(err);
  process.exit(1);
});
